# Chapter 37: Symbol Review

Review 94 symbols in Python 2.7.

## Keywords

* `and` - Logical `and`; Python doesn't support `&&`
* `del` - Deletes things.
    * An item in a list at an index, does not return it `del x[1]`
    * Delete a range `del x[2:4]`
    * The entire list `del [:]`
    * Delete variables `del x` (becomes not defined)
* `from` - Used to specify a method in module: `from math import sqrt()`
* `not` - Logical `not`; `!=` exists but `!!` won't work; `not not` will
* `while` - Self-explanatory.
    * Has optional `else` clause.
* `as` - Creates aliases for modules or `with` clause:
    * `import math as m`
    * `with open(file, 'a+') as nice_name`
* `elif` - `else if` equivalent but `else if` doesn't work.
* `global` - Allows you to read/write to global. Similar to PHP:
    *   ```
        x = 0
        def foobar():
            # x = x + 1 # UnboundLocalError: local variable
            global c
            x = x + 1
        ```
* `or` - Logicial `or`; `||` not supported
* `with` - Acts as both a try/catch(except) and an auto closing/releasing of resources:
    *   ```
        with open('/etc/passwd', 'r') as f:
        for line in f:
            print line
            ... more processing code ..
        ```
* `assert` - Fairly standard:
    *   ```
        assert x == 0, msg
        Traceback (most recent call last):
        File "<stdin>", line 1, in <module>
        AssertionError: fooba
        ```
* `else` - Self-explanatory. EXCEPT `while-else`:
    *   ```
        while x > 0:
            x -= 1
        else:
            print "Loop is done"
            print "Doesn't run if break; or exception happen."
        ```
* `if` -  Self-explanatory
* `pass` - null operation; it needs an operation to do something so use pass. Pops up in templates a bit. `class C: pass` `if False: pass`
* `yield` - Used in generators; no surprise here. JavaScript has generators that work the same.
* `break` - break loops. Only loops, no switches. Can't work with functions or classes within those loops. **skipping** the optional else
* `except` - try/catch --> try/except
* `import` - Used to import modules and methods.
* `print` - Prints. This changes Python 3.
* `class` - Self-explanatory
* `exec` - Like `eval()` or PHP `exec()`
* `in` - Used to check if value is in sequence. Must be iterable like list or string.
* `raise` - Throw Exception
* `continue` - Self-explanatory
* `finally` - Self-explanatory
* `is` - Confirms it is the same object (**not** type); `list1 is list2`
* `return` - Self-explanatory
* `def` - Declare functions
* `for` - Self-explanatory
* `lambda` - Much like JavaScript.
    * Syntax is different: `lambda x, y: x + y`.
    * Other names:
        * Anonymous functions
        * Lambda functions
        * Lambda expressions
        * Lambda abstractions
        * Lambda form
        * Function literals
* `try` - Self-explanatory

## Data Types

For data types, write out what makes up each one. For example, with strings write out how you
create a string. For numbers, write out a few numbers.
* `True` - Self-explanatory
    * **HOWEVER** in Python 2.7 they are variables/objects, in Python 3 they are keywords. This matters because:
    ```
    python
    Python 2.7.12 (default, Apr 15 2020, 17:07:12)
    [GCC 5.4.0 20160609] on linux2
    Type "help", "copyright", "credits" or "license" for more information.
    >>> True
    True
    >>> False
    False
    >>> True, False = False, True
    >>> True
    False
    >>> False
    True
    >>>
    ```
    Which is kind of hilarious.
* `False` - Self-explanatory.
    * In Python 2 the following are falsy:
        * `None`
        * `False`
        * zero of any numeric type: `0`, `0L` (long), `0.0` (float), `0j` (imaginary)
        * any empty sequence: `''`, `()`, `[]`
        * any empty mapping: `{}`
        * instance sof user-defined classes if they define `__nonzero__()` or `__len()__` methods that return `0` or `False`.
* `None` - Acts as the null in Python.
* `strings` - sequence of characters. Has a variety of methods:
    * https://docs.python.org/2.7/library/stdtypes.html#string-methods
    * `capitalize()` - First char is UPPERCASED by reset is lowercased: `"miXED CaSE".capitalize() # 'Mixed case'`
    * `center(width[, fillchar])` - Returns the string centered using `fillchar` (default space), does not trim existing spaces: `"xyz".center(10) # '   xyz    '`
    * `count(sub[, start, end])` - Count matching occurrences of string in specified range.
    * `encode(...)` `decode(...)` - See: https://docs.python.org/2.7/library/codecs.html#standard-encodings
    * `endswith(suffix[, start, end])` - `True`/`False` if string ends with. Can be a `tuple` (multiple suffixes) as well.
    * `expandtabs([tabsize])` - Converts spaces to tabs.
    * `find(sub[, start, end])` - Like `indexOf` Returns first occurrence of string match in range.
    * `format(*args, **kwargs)` - Basically like the formatting strings we do with `"%s" % (a)`. **Preferred format**
        * https://docs.python.org/2.7/library/string.html#formatstrings
        * **NOTE: In Python 3 this is the preferred format to `"%s" % (a)`**
    * `index(sub[, start, end])` - Like `find` but more aggressive. raises `ValueError` when it doesn't find it.
    * `isalnum()` - True if ALL chars in string are alpha-numeric (a space is not alpha-numeric). Locale dependant.
    * `isalpha()` - Same deal as above, but only alphabetic.
    * `isdigit()` - Self-explanatory.
    * `islower()` - True if all lower-case, ignoring non-alphabetic.
    * `isspace()` - True if non-empty and only spaces: `" \t ".isspace() # True`
    * `istitle()` - True if each "word" starts with capital letter followed by lowercase. Noting that is not necessarily **GRAMMATICAL** titles:
        *   ```
            # How an English title should be;
            >>> "The Book of Books".istitle()
            False
            >>> "The Book Of Books".istitle()
            True
            ```
        * See `title()`
    * `isupper()` - Same as `islower()`, but upper
    * `join(iterable)` - Joins the `iterable` with the glue that is the string: `",".join(['a', 'b', 'c']) # 'a,b,c'`
    * `ljust(width[, fillchar])` - Similar to `center()` but with left align justification. Adding padding to the right.
    * `lower()` - Pretty much `toLowerCase()`
    * `lstrip([chars])` - Performs a trim from the left side. Default is space but can be input string of multiple chars.
    * `partition(sep)` - Splits string into list/tuple of 3; 1st half, separator, 2nd half. No separator found results in full string + two empties.
    * `replace(old, new[, count])` - Replace matching string with new. Optional limit to first `count` occurrences.
    * `rfind(sub[, start, end])` - First **last** index in range; like `find()` but starts from right-to-left. -1 if not found.
    * `rindex(sub[, start, end])` - Like `index()`; raise error on failure, right-to-left find.
    * `rjust(width[, fillchar])` - Like `ljust()` but right aligned. Adding padding to the left.
    * `rpartition(sep)` - Much like `partition()` but starts from right-to-left. Return 3 items, 1st, sep, 2nd.
    * `rsplit([sep, maxsplit])` - Right-to-left split, default is space. `maxsplit` is number of splits to do before stopping, after which the original string is returned: `'a b c d e'.rsplit(' ', 2) # ['a b c', 'd', 'e']` Consecutive `sep` are treated as empty strings in result.
    * `rstrip([chars])` - Trim characters from the right, default space. Can input string with multiple chars.
    * `split([sep, maxsplit])` - Separate string, `maxsplit` times, left-to-right. Consecutive `sep` are treated as empty strings in result IF supplied:
        *   ```
            >>> 'a b c  d e'.split(' ', 3)
            ['a', 'b', 'c', ' d e']
            >>> 'a b c  d e'.split()
            ['a', 'b', 'c', 'd', 'e']
            >>> 'a b c  d e'.split(' ')
            ['a', 'b', 'c', '', 'd', 'e']
            >>>
            ```
    * `splitlines([keepends])` - Splits lines on universal newlines, however trailing new lines aren't "blank lines". `keepends` will split it but keep the end line chars intact.
        *   ```
            >>> "Everyone was \nfoo bar fighting\n".splitlines()
            ['Everyone was ', 'foo bar fighting']
            >>> "Everyone was \nfoo bar fighting\n".splitlines(True)
            ['Everyone was \n', 'foo bar fighting\n']
            ```
        * There is a unicode version that splits on unicode separators too.
    * `startswith(prefix[, start, end])` - Works like `endswith()`. `True`/`False` return.
    * `strip([chars])` - `trim()` from both sides. Can specify list of chars with string param.
    * `swapcase()` - Toggle the case of the characters:
        * `"Everyone was \nfoo bar fighting\n".swapcase() #   'eVERYONE WAS \nFOO BAR FIGHTING\n'`
    * `title()` - Creates a title to match the rules of `istitle()`. Is language independent, simply makes the first character at a word boundary be capital, following lowercase. Warning results may be amusing.
        * `"you're not too sure, ARE YOU?".title() # "You'Re Not Too Sure, Are You?"`
        * For English:  https://capitalizemytitle.com/
        > In general, the following capitalization rules apply across the four styles in title case:
        > * Capitalize the first word in the title
        > * Capitalize the last word in the title
        > * Capitalize the important words in the title
        >
        > **Important words** in that last bullet generally refer to:
        > * Adjectives (tiny, large, etc.)
        > * Adverbs (quietly, smoothly, etc.)
        > * Nouns (tablet, kitchen, book)
        > * Pronouns (they, she, he)
        > * Subordinating conjunctions (when fewer than 5 letters)
        > * Verbs (write, type, create)
    * `translate(table[, deletechars])` - Returns copy of string with multiple replacements/deletions. `maketrans()` in the string module may be of use here.
    * `upper()` - Does `toUpperCase()`
    * `zfill(width)` - Zero fill. Fills the number with 0s as you may want for consistent numbering. However, doesn't care if it's really a number in there.
    * `unicode.isnumeric()` - Includes things like unicode fractions.
    * `unicode.isdecimal()` - Includes numbery things like Unicode Arabic digit zero.
* `numbers` - Four distinct types. Operand with "narrower" type is widened to the other; plain int narrower than long narrower than float narrower than complex.
    * plain `integer()`: `0`
    * `float()`: `0.0`
    * `long()`: `0L`, `0l`
    * `complex()`: `0J`, `0j`
    * https://docs.python.org/2.7/library/stdtypes.html#numeric-types-int-float-long-complex
* `floats` - See above
* `lists` - A sequence type similar to arrays. Methods:
    * `list.append(x)` - Self-explanatory
    * `list.extend(L)` - Appends the parameter list to the extended list.
    * `list.insert(i, x)` - Self-explanatory. Index larger than list is the end, negative index will be start.
    * `list.remove(i)` - Self-explanatory. Error for no such item.
    * `list.index(x)` - Returns the index of first item to match x. **Error for no item.**
    * `list.count(x)` - Returns the number of times item if found in list. **Safe for no match.**
    * `list.sort(cmp=None, key=None, reverse=False)`
        * `cmp` - Comparison function to use: `cmp=lambda x,y: cmp(x.lower(), y.lower()`
        * `key` - The function to apply to values as a sorting key: `key=str.lower`
        * `reverse` - Sort reverse.
    * `reverse()` - Reverse the contents (not sorted, per se)
    * Consider also list comprehensions:
        * `squares = [x ** 2 for x in range(10)]` -> `[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]`
        * `[(x, y) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]` -> `[(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)]`

## String Escape Sequences

For string escape sequences, use them in strings to make sure they do what you think they do.
* `\\` -
* `\'` -
* `\"` -
* `\a` -
* `\b` -
* `\f` -
* `\n` -
* `\r` -
* `\t` -
* `\v` -

## String Formats

Same thing for string formats: use them in some strings to know what they do.
* `%d` -
* `%i` -
* `%o` -
* `%u` -
* `%x` -
* `%X` -
* `%e` -
* `%E` -
* `%f` -
* `%F` -
* `%g` -
* `%G` -
* `%c` -
* `%r` -
* `%s` -
* `%%` -

## Operators

Some of these may be unfamiliar to you, but look them up anyway. Find out what they do, and if
you still can’t figure it out, save it for later.
* `+` -
* `-` -
* `*` -
* `**` -
* `/` -
* `//` -
* `%` -
* `<` -
* `>` -
* `<=` -
* `>=` -
* `==` -
* `!=` -
* `<>` -
* `( )` -
* `[ ]` -
* `{ }` -
* `@` -
* `,` -
* `:` -
* `.` -
* `=` -
* `;` -
* `+=` -
* `- =` -
* `*=` -
* `/=` -
* `//=` -
* `%=` -
* `**=` -
